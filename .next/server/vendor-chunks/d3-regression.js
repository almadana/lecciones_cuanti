"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/d3-regression";
exports.ids = ["vendor-chunks/d3-regression"];
exports.modules = {

/***/ "(ssr)/./node_modules/d3-regression/dist/d3-regression.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-regression/dist/d3-regression.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   regressionExp: () => (/* binding */ exponential),\n/* harmony export */   regressionLinear: () => (/* binding */ linear),\n/* harmony export */   regressionLoess: () => (/* binding */ loess),\n/* harmony export */   regressionLog: () => (/* binding */ logarithmic),\n/* harmony export */   regressionPoly: () => (/* binding */ polynomial),\n/* harmony export */   regressionPow: () => (/* binding */ power),\n/* harmony export */   regressionQuad: () => (/* binding */ quad)\n/* harmony export */ });\n// https://github.com/HarryStevens/d3-regression#readme Version 1.3.10. Copyright 2022 Harry Stevens.\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\n// Adapted from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/points.js\nfunction points(data, x, y, sort) {\n  data = data.filter(function (d, i) {\n    var u = x(d, i),\n        v = y(d, i);\n    return u != null && isFinite(u) && v != null && isFinite(v);\n  });\n\n  if (sort) {\n    data.sort(function (a, b) {\n      return x(a) - x(b);\n    });\n  }\n\n  var n = data.length,\n      X = new Float64Array(n),\n      Y = new Float64Array(n); // extract values, calculate means\n\n  var ux = 0,\n      uy = 0,\n      xv,\n      yv,\n      d;\n\n  for (var i = 0; i < n;) {\n    d = data[i];\n    X[i] = xv = +x(d, i, data);\n    Y[i] = yv = +y(d, i, data);\n    ++i;\n    ux += (xv - ux) / i;\n    uy += (yv - uy) / i;\n  } // mean center the data\n\n\n  for (var _i = 0; _i < n; ++_i) {\n    X[_i] -= ux;\n    Y[_i] -= uy;\n  }\n\n  return [X, Y, ux, uy];\n}\nfunction visitPoints(data, x, y, cb) {\n  var iterations = 0;\n\n  for (var i = 0, n = data.length; i < n; i++) {\n    var d = data[i],\n        dx = +x(d, i, data),\n        dy = +y(d, i, data);\n\n    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {\n      cb(dx, dy, iterations++);\n    }\n  }\n}\n\n// return the coefficient of determination, or R squared.\n\nfunction determination(data, x, y, uY, predict) {\n  var SSE = 0,\n      SST = 0;\n  visitPoints(data, x, y, function (dx, dy) {\n    var sse = dy - predict(dx),\n        sst = dy - uY;\n    SSE += sse * sse;\n    SST += sst * sst;\n  });\n  return 1 - SSE / SST;\n}\n\n// Returns the angle of a line in degrees.\nfunction angle(line) {\n  return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;\n} // Returns the midpoint of a line.\n\nfunction midpoint(line) {\n  return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];\n}\n\n// returns a smooth line.\n\nfunction interpose(xmin, xmax, predict) {\n  var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;\n  var precision = 1 * Math.pow(10, -l / 2 - 1),\n      maxIter = 1e4;\n  var points = [px(xmin), px(xmax)],\n      iter = 0;\n\n  while (find(points) && iter < maxIter) {\n  }\n\n  return points;\n\n  function px(x) {\n    return [x, predict(x)];\n  }\n\n  function find(points) {\n    iter++;\n    var n = points.length;\n    var found = false;\n\n    for (var i = 0; i < n - 1; i++) {\n      var p0 = points[i],\n          p1 = points[i + 1],\n          m = midpoint([p0, p1]),\n          mp = px(m[0]),\n          a0 = angle([p0, m]),\n          a1 = angle([p0, mp]),\n          a = Math.abs(a0 - a1);\n\n      if (a > precision) {\n        points.splice(i + 1, 0, mp);\n        found = true;\n      }\n    }\n\n    return found;\n  }\n}\n\n// Ordinary Least Squares from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/ols.js\nfunction ols(uX, uY, uXY, uX2) {\n  var delta = uX2 - uX * uX,\n      slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,\n      intercept = uY - slope * uX;\n  return [intercept, slope];\n}\n\nfunction exponential () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      domain;\n\n  function exponential(data) {\n    var n = 0,\n        Y = 0,\n        YL = 0,\n        XY = 0,\n        XYL = 0,\n        X2Y = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, function (dx, dy) {\n      var ly = Math.log(dy),\n          xy = dx * dy;\n      ++n;\n      Y += (dy - Y) / n;\n      XY += (xy - XY) / n;\n      X2Y += (dx * xy - X2Y) / n;\n      YL += (dy * ly - YL) / n;\n      XYL += (xy * ly - XYL) / n;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y),\n        _ols2 = _slicedToArray(_ols, 2),\n        a = _ols2[0],\n        b = _ols2[1];\n\n    a = Math.exp(a);\n\n    var fn = function fn(x) {\n      return a * Math.exp(b * x);\n    },\n        out = interpose(xmin, xmax, fn);\n\n    out.a = a;\n    out.b = b;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  exponential.domain = function (arr) {\n    return arguments.length ? (domain = arr, exponential) : domain;\n  };\n\n  exponential.x = function (fn) {\n    return arguments.length ? (x = fn, exponential) : x;\n  };\n\n  exponential.y = function (fn) {\n    return arguments.length ? (y = fn, exponential) : y;\n  };\n\n  return exponential;\n}\n\nfunction linear () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      domain;\n\n  function linear(data) {\n    var n = 0,\n        X = 0,\n        // sum of x\n    Y = 0,\n        // sum of y\n    XY = 0,\n        // sum of x * y\n    X2 = 0,\n        // sum of x * x\n    xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, function (dx, dy) {\n      ++n;\n      X += (dx - X) / n;\n      Y += (dy - Y) / n;\n      XY += (dx * dy - XY) / n;\n      X2 += (dx * dx - X2) / n;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        intercept = _ols2[0],\n        slope = _ols2[1],\n        fn = function fn(x) {\n      return slope * x + intercept;\n    },\n        out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];\n\n    out.a = slope;\n    out.b = intercept;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  linear.domain = function (arr) {\n    return arguments.length ? (domain = arr, linear) : domain;\n  };\n\n  linear.x = function (fn) {\n    return arguments.length ? (x = fn, linear) : x;\n  };\n\n  linear.y = function (fn) {\n    return arguments.length ? (y = fn, linear) : y;\n  };\n\n  return linear;\n}\n\n// Returns the medium value of an array of numbers.\nfunction median(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  var i = arr.length / 2;\n  return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];\n}\n\nvar maxiters = 2,\n    epsilon = 1e-12;\nfunction loess () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      bandwidth = .3;\n\n  function loess(data) {\n    var _points = points(data, x, y, true),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length,\n        bw = Math.max(2, ~~(bandwidth * n)),\n        yhat = new Float64Array(n),\n        residuals = new Float64Array(n),\n        robustWeights = new Float64Array(n).fill(1);\n\n    for (var iter = -1; ++iter <= maxiters;) {\n      var interval = [0, bw - 1];\n\n      for (var i = 0; i < n; ++i) {\n        var dx = xv[i],\n            i0 = interval[0],\n            i1 = interval[1],\n            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;\n        var W = 0,\n            X = 0,\n            Y = 0,\n            XY = 0,\n            X2 = 0,\n            denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity\n\n        for (var k = i0; k <= i1; ++k) {\n          var xk = xv[k],\n              yk = yv[k],\n              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],\n              xkw = xk * w;\n          W += w;\n          X += xkw;\n          Y += yk * w;\n          XY += yk * xkw;\n          X2 += xk * xkw;\n        } // Linear regression fit\n\n\n        var _ols = ols(X / W, Y / W, XY / W, X2 / W),\n            _ols2 = _slicedToArray(_ols, 2),\n            a = _ols2[0],\n            b = _ols2[1];\n\n        yhat[i] = a + b * dx;\n        residuals[i] = Math.abs(yv[i] - yhat[i]);\n        updateInterval(xv, i + 1, interval);\n      }\n\n      if (iter === maxiters) {\n        break;\n      }\n\n      var medianResidual = median(residuals);\n      if (Math.abs(medianResidual) < epsilon) break;\n\n      for (var _i = 0, arg, _w; _i < n; ++_i) {\n        arg = residuals[_i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations\n        // Keeping weights tiny but non-zero prevents singularites\n\n        robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;\n      }\n    }\n\n    return output(xv, yhat, ux, uy);\n  }\n\n  loess.bandwidth = function (bw) {\n    return arguments.length ? (bandwidth = bw, loess) : bandwidth;\n  };\n\n  loess.x = function (fn) {\n    return arguments.length ? (x = fn, loess) : x;\n  };\n\n  loess.y = function (fn) {\n    return arguments.length ? (y = fn, loess) : y;\n  };\n\n  return loess;\n} // Weighting kernel for local regression\n\nfunction tricube(x) {\n  return (x = 1 - x * x * x) * x * x;\n} // Advance sliding window interval of nearest neighbors\n\n\nfunction updateInterval(xv, i, interval) {\n  var val = xv[i],\n      left = interval[0],\n      right = interval[1] + 1;\n  if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge\n  // Step when distance is equal to ensure movement over duplicate x values\n\n  while (i > left && xv[right] - val <= val - xv[left]) {\n    interval[0] = ++left;\n    interval[1] = right;\n    ++right;\n  }\n} // Generate smoothed output points\n// Average points with repeated x values\n\n\nfunction output(xv, yhat, ux, uy) {\n  var n = xv.length,\n      out = [];\n  var i = 0,\n      cnt = 0,\n      prev = [],\n      v;\n\n  for (; i < n; ++i) {\n    v = xv[i] + ux;\n\n    if (prev[0] === v) {\n      // Average output values via online update\n      prev[1] += (yhat[i] - prev[1]) / ++cnt;\n    } else {\n      // Add new output point\n      cnt = 0;\n      prev[1] += uy;\n      prev = [v, yhat[i]];\n      out.push(prev);\n    }\n  }\n\n  prev[1] += uy;\n  return out;\n}\n\nfunction logarithmic () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      base = Math.E,\n      domain;\n\n  function logarithmic(data) {\n    var n = 0,\n        X = 0,\n        Y = 0,\n        XY = 0,\n        X2 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity,\n        lb = Math.log(base);\n    visitPoints(data, x, y, function (dx, dy) {\n      var lx = Math.log(dx) / lb;\n      ++n;\n      X += (lx - X) / n;\n      Y += (dy - Y) / n;\n      XY += (lx * dy - XY) / n;\n      X2 += (lx * lx - X2) / n;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        intercept = _ols2[0],\n        slope = _ols2[1],\n        fn = function fn(x) {\n      return slope * Math.log(x) / lb + intercept;\n    },\n        out = interpose(xmin, xmax, fn);\n\n    out.a = slope;\n    out.b = intercept;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  logarithmic.domain = function (arr) {\n    return arguments.length ? (domain = arr, logarithmic) : domain;\n  };\n\n  logarithmic.x = function (fn) {\n    return arguments.length ? (x = fn, logarithmic) : x;\n  };\n\n  logarithmic.y = function (fn) {\n    return arguments.length ? (y = fn, logarithmic) : y;\n  };\n\n  logarithmic.base = function (n) {\n    return arguments.length ? (base = n, logarithmic) : base;\n  };\n\n  return logarithmic;\n}\n\nfunction quad () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      domain;\n\n  function quadratic(data) {\n    var _points = points(data, x, y),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length;\n\n    var X2 = 0,\n        X3 = 0,\n        X4 = 0,\n        XY = 0,\n        X2Y = 0,\n        i,\n        dx,\n        dy,\n        x2;\n\n    for (i = 0; i < n;) {\n      dx = xv[i];\n      dy = yv[i++];\n      x2 = dx * dx;\n      X2 += (x2 - X2) / i;\n      X3 += (x2 * dx - X3) / i;\n      X4 += (x2 * x2 - X4) / i;\n      XY += (dx * dy - XY) / i;\n      X2Y += (x2 * dy - X2Y) / i;\n    }\n\n    var Y = 0,\n        n0 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, function (dx, dy) {\n      n0++;\n      Y += (dy - Y) / n0;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    var X2X2 = X4 - X2 * X2,\n        d = X2 * X2X2 - X3 * X3,\n        a = (X2Y * X2 - XY * X3) / d,\n        b = (XY * X2X2 - X2Y * X3) / d,\n        c = -a * X2,\n        fn = function fn(x) {\n      x = x - ux;\n      return a * x * x + b * x + c + uy;\n    };\n\n    var out = interpose(xmin, xmax, fn);\n    out.a = a;\n    out.b = b - 2 * a * ux;\n    out.c = c - b * ux + a * ux * ux + uy;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  quadratic.domain = function (arr) {\n    return arguments.length ? (domain = arr, quadratic) : domain;\n  };\n\n  quadratic.x = function (fn) {\n    return arguments.length ? (x = fn, quadratic) : x;\n  };\n\n  quadratic.y = function (fn) {\n    return arguments.length ? (y = fn, quadratic) : y;\n  };\n\n  return quadratic;\n}\n\n// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246\n// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE\n// ...with ideas from vega-statistics by Jeffrey Heer\n// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/poly.js\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n\nfunction polynomial () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      order = 3,\n      domain;\n\n  function polynomial(data) {\n    // Use more efficient methods for lower orders\n    if (order === 1) {\n      var o = linear().x(x).y(y).domain(domain)(data);\n      o.coefficients = [o.b, o.a];\n      delete o.a;\n      delete o.b;\n      return o;\n    }\n\n    if (order === 2) {\n      var _o = quad().x(x).y(y).domain(domain)(data);\n\n      _o.coefficients = [_o.c, _o.b, _o.a];\n      delete _o.a;\n      delete _o.b;\n      delete _o.c;\n      return _o;\n    }\n\n    var _points = points(data, x, y),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length,\n        lhs = [],\n        rhs = [],\n        k = order + 1;\n\n    var Y = 0,\n        n0 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, function (dx, dy) {\n      ++n0;\n      Y += (dy - Y) / n0;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n    var i, j, l, v, c;\n\n    for (i = 0; i < k; ++i) {\n      for (l = 0, v = 0; l < n; ++l) {\n        v += Math.pow(xv[l], i) * yv[l];\n      }\n\n      lhs.push(v);\n      c = new Float64Array(k);\n\n      for (j = 0; j < k; ++j) {\n        for (l = 0, v = 0; l < n; ++l) {\n          v += Math.pow(xv[l], i + j);\n        }\n\n        c[j] = v;\n      }\n\n      rhs.push(c);\n    }\n\n    rhs.push(lhs);\n\n    var coef = gaussianElimination(rhs),\n        fn = function fn(x) {\n      x -= ux;\n      var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;\n\n      for (i = 3; i < k; ++i) {\n        y += coef[i] * Math.pow(x, i);\n      }\n\n      return y;\n    },\n        out = interpose(xmin, xmax, fn);\n\n    out.coefficients = uncenter(k, coef, -ux, uy);\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  polynomial.domain = function (arr) {\n    return arguments.length ? (domain = arr, polynomial) : domain;\n  };\n\n  polynomial.x = function (fn) {\n    return arguments.length ? (x = fn, polynomial) : x;\n  };\n\n  polynomial.y = function (fn) {\n    return arguments.length ? (y = fn, polynomial) : y;\n  };\n\n  polynomial.order = function (n) {\n    return arguments.length ? (order = n, polynomial) : order;\n  };\n\n  return polynomial;\n}\n\nfunction uncenter(k, a, x, y) {\n  var z = Array(k);\n  var i, j, v, c; // initialize to zero\n\n  for (i = 0; i < k; ++i) {\n    z[i] = 0;\n  } // polynomial expansion\n\n\n  for (i = k - 1; i >= 0; --i) {\n    v = a[i];\n    c = 1;\n    z[i] += v;\n\n    for (j = 1; j <= i; ++j) {\n      c *= (i + 1 - j) / j; // binomial coefficent\n\n      z[i - j] += v * Math.pow(x, j) * c;\n    }\n  } // bias term\n\n\n  z[0] += y;\n  return z;\n} // Given an array for a two-dimensional matrix and the polynomial order,\n// solve A * x = b using Gaussian elimination.\n\n\nfunction gaussianElimination(matrix) {\n  var n = matrix.length - 1,\n      coef = [];\n  var i, j, k, r, t;\n\n  for (i = 0; i < n; ++i) {\n    r = i; // max row\n\n    for (j = i + 1; j < n; ++j) {\n      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {\n        r = j;\n      }\n    }\n\n    for (k = i; k < n + 1; ++k) {\n      t = matrix[k][i];\n      matrix[k][i] = matrix[k][r];\n      matrix[k][r] = t;\n    }\n\n    for (j = i + 1; j < n; ++j) {\n      for (k = n; k >= i; k--) {\n        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];\n      }\n    }\n  }\n\n  for (j = n - 1; j >= 0; --j) {\n    t = 0;\n\n    for (k = j + 1; k < n; ++k) {\n      t += matrix[k][j] * coef[k];\n    }\n\n    coef[j] = (matrix[n][j] - t) / matrix[j][j];\n  }\n\n  return coef;\n}\n\nfunction power () {\n  var x = function x(d) {\n    return d[0];\n  },\n      y = function y(d) {\n    return d[1];\n  },\n      domain;\n\n  function power(data) {\n    var n = 0,\n        X = 0,\n        Y = 0,\n        XY = 0,\n        X2 = 0,\n        YS = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, function (dx, dy) {\n      var lx = Math.log(dx),\n          ly = Math.log(dy);\n      ++n;\n      X += (lx - X) / n;\n      Y += (ly - Y) / n;\n      XY += (lx * ly - XY) / n;\n      X2 += (lx * lx - X2) / n;\n      YS += (dy - YS) / n;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        a = _ols2[0],\n        b = _ols2[1];\n\n    a = Math.exp(a);\n\n    var fn = function fn(x) {\n      return a * Math.pow(x, b);\n    },\n        out = interpose(xmin, xmax, fn);\n\n    out.a = a;\n    out.b = b;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, YS, fn);\n    return out;\n  }\n\n  power.domain = function (arr) {\n    return arguments.length ? (domain = arr, power) : domain;\n  };\n\n  power.x = function (fn) {\n    return arguments.length ? (x = fn, power) : x;\n  };\n\n  power.y = function (fn) {\n    return arguments.length ? (y = fn, power) : y;\n  };\n\n  return power;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtcmVncmVzc2lvbi9kaXN0L2QzLXJlZ3Jlc3Npb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FB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bnRpL3YyL25vZGVfbW9kdWxlcy9kMy1yZWdyZXNzaW9uL2Rpc3QvZDMtcmVncmVzc2lvbi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uI3JlYWRtZSBWZXJzaW9uIDEuMy4xMC4gQ29weXJpZ2h0IDIwMjIgSGFycnkgU3RldmVucy5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIHZlZ2Etc3RhdGlzdGljcyBieSBKZWZmcmV5IEhlZXJcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EvYmxvYi9mMDU4YjA5OWRlY2FkOWRiNzgzMDE0MDVkZDBkMmU5ZDhiYTNkNTFhL0xJQ0VOU0Vcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YwNThiMDk5ZGVjYWQ5ZGI3ODMwMTQwNWRkMGQyZTlkOGJhM2Q1MWEvcGFja2FnZXMvdmVnYS1zdGF0aXN0aWNzL3NyYy9yZWdyZXNzaW9uL3BvaW50cy5qc1xuZnVuY3Rpb24gcG9pbnRzKGRhdGEsIHgsIHksIHNvcnQpIHtcbiAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgdmFyIHUgPSB4KGQsIGkpLFxuICAgICAgICB2ID0geShkLCBpKTtcbiAgICByZXR1cm4gdSAhPSBudWxsICYmIGlzRmluaXRlKHUpICYmIHYgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2KTtcbiAgfSk7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB4KGEpIC0geChiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBuID0gZGF0YS5sZW5ndGgsXG4gICAgICBYID0gbmV3IEZsb2F0NjRBcnJheShuKSxcbiAgICAgIFkgPSBuZXcgRmxvYXQ2NEFycmF5KG4pOyAvLyBleHRyYWN0IHZhbHVlcywgY2FsY3VsYXRlIG1lYW5zXG5cbiAgdmFyIHV4ID0gMCxcbiAgICAgIHV5ID0gMCxcbiAgICAgIHh2LFxuICAgICAgeXYsXG4gICAgICBkO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjspIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBYW2ldID0geHYgPSAreChkLCBpLCBkYXRhKTtcbiAgICBZW2ldID0geXYgPSAreShkLCBpLCBkYXRhKTtcbiAgICArK2k7XG4gICAgdXggKz0gKHh2IC0gdXgpIC8gaTtcbiAgICB1eSArPSAoeXYgLSB1eSkgLyBpO1xuICB9IC8vIG1lYW4gY2VudGVyIHRoZSBkYXRhXG5cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjsgKytfaSkge1xuICAgIFhbX2ldIC09IHV4O1xuICAgIFlbX2ldIC09IHV5O1xuICB9XG5cbiAgcmV0dXJuIFtYLCBZLCB1eCwgdXldO1xufVxuZnVuY3Rpb24gdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgY2IpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgZCA9IGRhdGFbaV0sXG4gICAgICAgIGR4ID0gK3goZCwgaSwgZGF0YSksXG4gICAgICAgIGR5ID0gK3koZCwgaSwgZGF0YSk7XG5cbiAgICBpZiAoZHggIT0gbnVsbCAmJiBpc0Zpbml0ZShkeCkgJiYgZHkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkeSkpIHtcbiAgICAgIGNiKGR4LCBkeSwgaXRlcmF0aW9ucysrKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcmV0dXJuIHRoZSBjb2VmZmljaWVudCBvZiBkZXRlcm1pbmF0aW9uLCBvciBSIHNxdWFyZWQuXG5cbmZ1bmN0aW9uIGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgdVksIHByZWRpY3QpIHtcbiAgdmFyIFNTRSA9IDAsXG4gICAgICBTU1QgPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgdmFyIHNzZSA9IGR5IC0gcHJlZGljdChkeCksXG4gICAgICAgIHNzdCA9IGR5IC0gdVk7XG4gICAgU1NFICs9IHNzZSAqIHNzZTtcbiAgICBTU1QgKz0gc3N0ICogc3N0O1xuICB9KTtcbiAgcmV0dXJuIDEgLSBTU0UgLyBTU1Q7XG59XG5cbi8vIFJldHVybnMgdGhlIGFuZ2xlIG9mIGEgbGluZSBpbiBkZWdyZWVzLlxuZnVuY3Rpb24gYW5nbGUobGluZSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihsaW5lWzFdWzFdIC0gbGluZVswXVsxXSwgbGluZVsxXVswXSAtIGxpbmVbMF1bMF0pICogMTgwIC8gTWF0aC5QSTtcbn0gLy8gUmV0dXJucyB0aGUgbWlkcG9pbnQgb2YgYSBsaW5lLlxuXG5mdW5jdGlvbiBtaWRwb2ludChsaW5lKSB7XG4gIHJldHVybiBbKGxpbmVbMF1bMF0gKyBsaW5lWzFdWzBdKSAvIDIsIChsaW5lWzBdWzFdICsgbGluZVsxXVsxXSkgLyAyXTtcbn1cblxuLy8gcmV0dXJucyBhIHNtb290aCBsaW5lLlxuXG5mdW5jdGlvbiBpbnRlcnBvc2UoeG1pbiwgeG1heCwgcHJlZGljdCkge1xuICB2YXIgbCA9IE1hdGgubG9nKHhtYXggLSB4bWluKSAqIE1hdGguTE9HMTBFICsgMSB8IDA7XG4gIHZhciBwcmVjaXNpb24gPSAxICogTWF0aC5wb3coMTAsIC1sIC8gMiAtIDEpLFxuICAgICAgbWF4SXRlciA9IDFlNDtcbiAgdmFyIHBvaW50cyA9IFtweCh4bWluKSwgcHgoeG1heCldLFxuICAgICAgaXRlciA9IDA7XG5cbiAgd2hpbGUgKGZpbmQocG9pbnRzKSAmJiBpdGVyIDwgbWF4SXRlcikge1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcblxuICBmdW5jdGlvbiBweCh4KSB7XG4gICAgcmV0dXJuIFt4LCBwcmVkaWN0KHgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmQocG9pbnRzKSB7XG4gICAgaXRlcisrO1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgdmFyIHAwID0gcG9pbnRzW2ldLFxuICAgICAgICAgIHAxID0gcG9pbnRzW2kgKyAxXSxcbiAgICAgICAgICBtID0gbWlkcG9pbnQoW3AwLCBwMV0pLFxuICAgICAgICAgIG1wID0gcHgobVswXSksXG4gICAgICAgICAgYTAgPSBhbmdsZShbcDAsIG1dKSxcbiAgICAgICAgICBhMSA9IGFuZ2xlKFtwMCwgbXBdKSxcbiAgICAgICAgICBhID0gTWF0aC5hYnMoYTAgLSBhMSk7XG5cbiAgICAgIGlmIChhID4gcHJlY2lzaW9uKSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaSArIDEsIDAsIG1wKTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxufVxuXG4vLyBPcmRpbmFyeSBMZWFzdCBTcXVhcmVzIGZyb20gdmVnYS1zdGF0aXN0aWNzIGJ5IEplZmZyZXkgSGVlclxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YwNThiMDk5ZGVjYWQ5ZGI3ODMwMTQwNWRkMGQyZTlkOGJhM2Q1MWEvTElDRU5TRVxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhL2Jsb2IvZjA1OGIwOTlkZWNhZDlkYjc4MzAxNDA1ZGQwZDJlOWQ4YmEzZDUxYS9wYWNrYWdlcy92ZWdhLXN0YXRpc3RpY3Mvc3JjL3JlZ3Jlc3Npb24vb2xzLmpzXG5mdW5jdGlvbiBvbHModVgsIHVZLCB1WFksIHVYMikge1xuICB2YXIgZGVsdGEgPSB1WDIgLSB1WCAqIHVYLFxuICAgICAgc2xvcGUgPSBNYXRoLmFicyhkZWx0YSkgPCAxZS0yNCA/IDAgOiAodVhZIC0gdVggKiB1WSkgLyBkZWx0YSxcbiAgICAgIGludGVyY2VwdCA9IHVZIC0gc2xvcGUgKiB1WDtcbiAgcmV0dXJuIFtpbnRlcmNlcHQsIHNsb3BlXTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIGV4cG9uZW50aWFsKGRhdGEpIHtcbiAgICB2YXIgbiA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBZTCA9IDAsXG4gICAgICAgIFhZID0gMCxcbiAgICAgICAgWFlMID0gMCxcbiAgICAgICAgWDJZID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgdmFyIGx5ID0gTWF0aC5sb2coZHkpLFxuICAgICAgICAgIHh5ID0gZHggKiBkeTtcbiAgICAgICsrbjtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgICAgWFkgKz0gKHh5IC0gWFkpIC8gbjtcbiAgICAgIFgyWSArPSAoZHggKiB4eSAtIFgyWSkgLyBuO1xuICAgICAgWUwgKz0gKGR5ICogbHkgLSBZTCkgLyBuO1xuICAgICAgWFlMICs9ICh4eSAqIGx5IC0gWFlMKSAvIG47XG5cbiAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgIGlmIChkeCA8IHhtaW4pIHhtaW4gPSBkeDtcbiAgICAgICAgaWYgKGR4ID4geG1heCkgeG1heCA9IGR4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF9vbHMgPSBvbHMoWFkgLyBZLCBZTCAvIFksIFhZTCAvIFksIFgyWSAvIFkpLFxuICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICBhID0gX29sczJbMF0sXG4gICAgICAgIGIgPSBfb2xzMlsxXTtcblxuICAgIGEgPSBNYXRoLmV4cChhKTtcblxuICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIHJldHVybiBhICogTWF0aC5leHAoYiAqIHgpO1xuICAgIH0sXG4gICAgICAgIG91dCA9IGludGVycG9zZSh4bWluLCB4bWF4LCBmbik7XG5cbiAgICBvdXQuYSA9IGE7XG4gICAgb3V0LmIgPSBiO1xuICAgIG91dC5wcmVkaWN0ID0gZm47XG4gICAgb3V0LnJTcXVhcmVkID0gZGV0ZXJtaW5hdGlvbihkYXRhLCB4LCB5LCBZLCBmbik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGV4cG9uZW50aWFsLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIGV4cG9uZW50aWFsKSA6IGRvbWFpbjtcbiAgfTtcblxuICBleHBvbmVudGlhbC54ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IGZuLCBleHBvbmVudGlhbCkgOiB4O1xuICB9O1xuXG4gIGV4cG9uZW50aWFsLnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gZm4sIGV4cG9uZW50aWFsKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGV4cG9uZW50aWFsO1xufVxuXG5mdW5jdGlvbiBsaW5lYXIgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIGxpbmVhcihkYXRhKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBYID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHhcbiAgICBZID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHlcbiAgICBYWSA9IDAsXG4gICAgICAgIC8vIHN1bSBvZiB4ICogeVxuICAgIFgyID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHggKiB4XG4gICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgKytuO1xuICAgICAgWCArPSAoZHggLSBYKSAvIG47XG4gICAgICBZICs9IChkeSAtIFkpIC8gbjtcbiAgICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICAgIFgyICs9IChkeCAqIGR4IC0gWDIpIC8gbjtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgaWYgKGR4IDwgeG1pbikgeG1pbiA9IGR4O1xuICAgICAgICBpZiAoZHggPiB4bWF4KSB4bWF4ID0gZHg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgX29scyA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICBpbnRlcmNlcHQgPSBfb2xzMlswXSxcbiAgICAgICAgc2xvcGUgPSBfb2xzMlsxXSxcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICByZXR1cm4gc2xvcGUgKiB4ICsgaW50ZXJjZXB0O1xuICAgIH0sXG4gICAgICAgIG91dCA9IFtbeG1pbiwgZm4oeG1pbildLCBbeG1heCwgZm4oeG1heCldXTtcblxuICAgIG91dC5hID0gc2xvcGU7XG4gICAgb3V0LmIgPSBpbnRlcmNlcHQ7XG4gICAgb3V0LnByZWRpY3QgPSBmbjtcbiAgICBvdXQuclNxdWFyZWQgPSBkZXRlcm1pbmF0aW9uKGRhdGEsIHgsIHksIFksIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbGluZWFyLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIGxpbmVhcikgOiBkb21haW47XG4gIH07XG5cbiAgbGluZWFyLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIGxpbmVhcikgOiB4O1xuICB9O1xuXG4gIGxpbmVhci55ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IGZuLCBsaW5lYXIpIDogeTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBtZWRpdW0gdmFsdWUgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbmZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICB2YXIgaSA9IGFyci5sZW5ndGggLyAyO1xuICByZXR1cm4gaSAlIDEgPT09IDAgPyAoYXJyW2kgLSAxXSArIGFycltpXSkgLyAyIDogYXJyW01hdGguZmxvb3IoaSldO1xufVxuXG52YXIgbWF4aXRlcnMgPSAyLFxuICAgIGVwc2lsb24gPSAxZS0xMjtcbmZ1bmN0aW9uIGxvZXNzICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGJhbmR3aWR0aCA9IC4zO1xuXG4gIGZ1bmN0aW9uIGxvZXNzKGRhdGEpIHtcbiAgICB2YXIgX3BvaW50cyA9IHBvaW50cyhkYXRhLCB4LCB5LCB0cnVlKSxcbiAgICAgICAgX3BvaW50czIgPSBfc2xpY2VkVG9BcnJheShfcG9pbnRzLCA0KSxcbiAgICAgICAgeHYgPSBfcG9pbnRzMlswXSxcbiAgICAgICAgeXYgPSBfcG9pbnRzMlsxXSxcbiAgICAgICAgdXggPSBfcG9pbnRzMlsyXSxcbiAgICAgICAgdXkgPSBfcG9pbnRzMlszXSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgYncgPSBNYXRoLm1heCgyLCB+fihiYW5kd2lkdGggKiBuKSksXG4gICAgICAgIHloYXQgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByZXNpZHVhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByb2J1c3RXZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShuKS5maWxsKDEpO1xuXG4gICAgZm9yICh2YXIgaXRlciA9IC0xOyArK2l0ZXIgPD0gbWF4aXRlcnM7KSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBbMCwgYncgLSAxXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGR4ID0geHZbaV0sXG4gICAgICAgICAgICBpMCA9IGludGVydmFsWzBdLFxuICAgICAgICAgICAgaTEgPSBpbnRlcnZhbFsxXSxcbiAgICAgICAgICAgIGVkZ2UgPSBkeCAtIHh2W2kwXSA+IHh2W2kxXSAtIGR4ID8gaTAgOiBpMTtcbiAgICAgICAgdmFyIFcgPSAwLFxuICAgICAgICAgICAgWCA9IDAsXG4gICAgICAgICAgICBZID0gMCxcbiAgICAgICAgICAgIFhZID0gMCxcbiAgICAgICAgICAgIFgyID0gMCxcbiAgICAgICAgICAgIGRlbm9tID0gMSAvIE1hdGguYWJzKHh2W2VkZ2VdIC0gZHggfHwgMSk7IC8vIEF2b2lkIHNpbmd1bGFyaXR5XG5cbiAgICAgICAgZm9yICh2YXIgayA9IGkwOyBrIDw9IGkxOyArK2spIHtcbiAgICAgICAgICB2YXIgeGsgPSB4dltrXSxcbiAgICAgICAgICAgICAgeWsgPSB5dltrXSxcbiAgICAgICAgICAgICAgdyA9IHRyaWN1YmUoTWF0aC5hYnMoZHggLSB4aykgKiBkZW5vbSkgKiByb2J1c3RXZWlnaHRzW2tdLFxuICAgICAgICAgICAgICB4a3cgPSB4ayAqIHc7XG4gICAgICAgICAgVyArPSB3O1xuICAgICAgICAgIFggKz0geGt3O1xuICAgICAgICAgIFkgKz0geWsgKiB3O1xuICAgICAgICAgIFhZICs9IHlrICogeGt3O1xuICAgICAgICAgIFgyICs9IHhrICogeGt3O1xuICAgICAgICB9IC8vIExpbmVhciByZWdyZXNzaW9uIGZpdFxuXG5cbiAgICAgICAgdmFyIF9vbHMgPSBvbHMoWCAvIFcsIFkgLyBXLCBYWSAvIFcsIFgyIC8gVyksXG4gICAgICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICAgICAgYSA9IF9vbHMyWzBdLFxuICAgICAgICAgICAgYiA9IF9vbHMyWzFdO1xuXG4gICAgICAgIHloYXRbaV0gPSBhICsgYiAqIGR4O1xuICAgICAgICByZXNpZHVhbHNbaV0gPSBNYXRoLmFicyh5dltpXSAtIHloYXRbaV0pO1xuICAgICAgICB1cGRhdGVJbnRlcnZhbCh4diwgaSArIDEsIGludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXIgPT09IG1heGl0ZXJzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVkaWFuUmVzaWR1YWwgPSBtZWRpYW4ocmVzaWR1YWxzKTtcbiAgICAgIGlmIChNYXRoLmFicyhtZWRpYW5SZXNpZHVhbCkgPCBlcHNpbG9uKSBicmVhaztcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBhcmcsIF93OyBfaSA8IG47ICsrX2kpIHtcbiAgICAgICAgYXJnID0gcmVzaWR1YWxzW19pXSAvICg2ICogbWVkaWFuUmVzaWR1YWwpOyAvLyBEZWZhdWx0IHRvIGVwc2lsb24gKHJhdGhlciB0aGFuIHplcm8pIGZvciBsYXJnZSBkZXZpYXRpb25zXG4gICAgICAgIC8vIEtlZXBpbmcgd2VpZ2h0cyB0aW55IGJ1dCBub24temVybyBwcmV2ZW50cyBzaW5ndWxhcml0ZXNcblxuICAgICAgICByb2J1c3RXZWlnaHRzW19pXSA9IGFyZyA+PSAxID8gZXBzaWxvbiA6IChfdyA9IDEgLSBhcmcgKiBhcmcpICogX3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KTtcbiAgfVxuXG4gIGxvZXNzLmJhbmR3aWR0aCA9IGZ1bmN0aW9uIChidykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhbmR3aWR0aCA9IGJ3LCBsb2VzcykgOiBiYW5kd2lkdGg7XG4gIH07XG5cbiAgbG9lc3MueCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBmbiwgbG9lc3MpIDogeDtcbiAgfTtcblxuICBsb2Vzcy55ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IGZuLCBsb2VzcykgOiB5O1xuICB9O1xuXG4gIHJldHVybiBsb2Vzcztcbn0gLy8gV2VpZ2h0aW5nIGtlcm5lbCBmb3IgbG9jYWwgcmVncmVzc2lvblxuXG5mdW5jdGlvbiB0cmljdWJlKHgpIHtcbiAgcmV0dXJuICh4ID0gMSAtIHggKiB4ICogeCkgKiB4ICogeDtcbn0gLy8gQWR2YW5jZSBzbGlkaW5nIHdpbmRvdyBpbnRlcnZhbCBvZiBuZWFyZXN0IG5laWdoYm9yc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUludGVydmFsKHh2LCBpLCBpbnRlcnZhbCkge1xuICB2YXIgdmFsID0geHZbaV0sXG4gICAgICBsZWZ0ID0gaW50ZXJ2YWxbMF0sXG4gICAgICByaWdodCA9IGludGVydmFsWzFdICsgMTtcbiAgaWYgKHJpZ2h0ID49IHh2Lmxlbmd0aCkgcmV0dXJuOyAvLyBTdGVwIHJpZ2h0IGlmIGRpc3RhbmNlIHRvIG5ldyByaWdodCBlZGdlIGlzIDw9IGRpc3RhbmNlIHRvIG9sZCBsZWZ0IGVkZ2VcbiAgLy8gU3RlcCB3aGVuIGRpc3RhbmNlIGlzIGVxdWFsIHRvIGVuc3VyZSBtb3ZlbWVudCBvdmVyIGR1cGxpY2F0ZSB4IHZhbHVlc1xuXG4gIHdoaWxlIChpID4gbGVmdCAmJiB4dltyaWdodF0gLSB2YWwgPD0gdmFsIC0geHZbbGVmdF0pIHtcbiAgICBpbnRlcnZhbFswXSA9ICsrbGVmdDtcbiAgICBpbnRlcnZhbFsxXSA9IHJpZ2h0O1xuICAgICsrcmlnaHQ7XG4gIH1cbn0gLy8gR2VuZXJhdGUgc21vb3RoZWQgb3V0cHV0IHBvaW50c1xuLy8gQXZlcmFnZSBwb2ludHMgd2l0aCByZXBlYXRlZCB4IHZhbHVlc1xuXG5cbmZ1bmN0aW9uIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KSB7XG4gIHZhciBuID0geHYubGVuZ3RoLFxuICAgICAgb3V0ID0gW107XG4gIHZhciBpID0gMCxcbiAgICAgIGNudCA9IDAsXG4gICAgICBwcmV2ID0gW10sXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgdiA9IHh2W2ldICsgdXg7XG5cbiAgICBpZiAocHJldlswXSA9PT0gdikge1xuICAgICAgLy8gQXZlcmFnZSBvdXRwdXQgdmFsdWVzIHZpYSBvbmxpbmUgdXBkYXRlXG4gICAgICBwcmV2WzFdICs9ICh5aGF0W2ldIC0gcHJldlsxXSkgLyArK2NudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIG5ldyBvdXRwdXQgcG9pbnRcbiAgICAgIGNudCA9IDA7XG4gICAgICBwcmV2WzFdICs9IHV5O1xuICAgICAgcHJldiA9IFt2LCB5aGF0W2ldXTtcbiAgICAgIG91dC5wdXNoKHByZXYpO1xuICAgIH1cbiAgfVxuXG4gIHByZXZbMV0gKz0gdXk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGxvZ2FyaXRobWljICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGJhc2UgPSBNYXRoLkUsXG4gICAgICBkb21haW47XG5cbiAgZnVuY3Rpb24gbG9nYXJpdGhtaWMoZGF0YSkge1xuICAgIHZhciBuID0gMCxcbiAgICAgICAgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBYWSA9IDAsXG4gICAgICAgIFgyID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHksXG4gICAgICAgIGxiID0gTWF0aC5sb2coYmFzZSk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgdmFyIGx4ID0gTWF0aC5sb2coZHgpIC8gbGI7XG4gICAgICArK247XG4gICAgICBYICs9IChseCAtIFgpIC8gbjtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgICAgWFkgKz0gKGx4ICogZHkgLSBYWSkgLyBuO1xuICAgICAgWDIgKz0gKGx4ICogbHggLSBYMikgLyBuO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfb2xzID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgICAgIF9vbHMyID0gX3NsaWNlZFRvQXJyYXkoX29scywgMiksXG4gICAgICAgIGludGVyY2VwdCA9IF9vbHMyWzBdLFxuICAgICAgICBzbG9wZSA9IF9vbHMyWzFdLFxuICAgICAgICBmbiA9IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIHJldHVybiBzbG9wZSAqIE1hdGgubG9nKHgpIC8gbGIgKyBpbnRlcmNlcHQ7XG4gICAgfSxcbiAgICAgICAgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcblxuICAgIG91dC5hID0gc2xvcGU7XG4gICAgb3V0LmIgPSBpbnRlcmNlcHQ7XG4gICAgb3V0LnByZWRpY3QgPSBmbjtcbiAgICBvdXQuclNxdWFyZWQgPSBkZXRlcm1pbmF0aW9uKGRhdGEsIHgsIHksIFksIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbG9nYXJpdGhtaWMuZG9tYWluID0gZnVuY3Rpb24gKGFycikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IGFyciwgbG9nYXJpdGhtaWMpIDogZG9tYWluO1xuICB9O1xuXG4gIGxvZ2FyaXRobWljLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIGxvZ2FyaXRobWljKSA6IHg7XG4gIH07XG5cbiAgbG9nYXJpdGhtaWMueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgbG9nYXJpdGhtaWMpIDogeTtcbiAgfTtcblxuICBsb2dhcml0aG1pYy5iYXNlID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gbiwgbG9nYXJpdGhtaWMpIDogYmFzZTtcbiAgfTtcblxuICByZXR1cm4gbG9nYXJpdGhtaWM7XG59XG5cbmZ1bmN0aW9uIHF1YWQgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIHF1YWRyYXRpYyhkYXRhKSB7XG4gICAgdmFyIF9wb2ludHMgPSBwb2ludHMoZGF0YSwgeCwgeSksXG4gICAgICAgIF9wb2ludHMyID0gX3NsaWNlZFRvQXJyYXkoX3BvaW50cywgNCksXG4gICAgICAgIHh2ID0gX3BvaW50czJbMF0sXG4gICAgICAgIHl2ID0gX3BvaW50czJbMV0sXG4gICAgICAgIHV4ID0gX3BvaW50czJbMl0sXG4gICAgICAgIHV5ID0gX3BvaW50czJbM10sXG4gICAgICAgIG4gPSB4di5sZW5ndGg7XG5cbiAgICB2YXIgWDIgPSAwLFxuICAgICAgICBYMyA9IDAsXG4gICAgICAgIFg0ID0gMCxcbiAgICAgICAgWFkgPSAwLFxuICAgICAgICBYMlkgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBkeCxcbiAgICAgICAgZHksXG4gICAgICAgIHgyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47KSB7XG4gICAgICBkeCA9IHh2W2ldO1xuICAgICAgZHkgPSB5dltpKytdO1xuICAgICAgeDIgPSBkeCAqIGR4O1xuICAgICAgWDIgKz0gKHgyIC0gWDIpIC8gaTtcbiAgICAgIFgzICs9ICh4MiAqIGR4IC0gWDMpIC8gaTtcbiAgICAgIFg0ICs9ICh4MiAqIHgyIC0gWDQpIC8gaTtcbiAgICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gaTtcbiAgICAgIFgyWSArPSAoeDIgKiBkeSAtIFgyWSkgLyBpO1xuICAgIH1cblxuICAgIHZhciBZID0gMCxcbiAgICAgICAgbjAgPSAwLFxuICAgICAgICB4bWluID0gZG9tYWluID8gK2RvbWFpblswXSA6IEluZmluaXR5LFxuICAgICAgICB4bWF4ID0gZG9tYWluID8gK2RvbWFpblsxXSA6IC1JbmZpbml0eTtcbiAgICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICBuMCsrO1xuICAgICAgWSArPSAoZHkgLSBZKSAvIG4wO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBYMlgyID0gWDQgLSBYMiAqIFgyLFxuICAgICAgICBkID0gWDIgKiBYMlgyIC0gWDMgKiBYMyxcbiAgICAgICAgYSA9IChYMlkgKiBYMiAtIFhZICogWDMpIC8gZCxcbiAgICAgICAgYiA9IChYWSAqIFgyWDIgLSBYMlkgKiBYMykgLyBkLFxuICAgICAgICBjID0gLWEgKiBYMixcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICB4ID0geCAtIHV4O1xuICAgICAgcmV0dXJuIGEgKiB4ICogeCArIGIgKiB4ICsgYyArIHV5O1xuICAgIH07XG5cbiAgICB2YXIgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcbiAgICBvdXQuYSA9IGE7XG4gICAgb3V0LmIgPSBiIC0gMiAqIGEgKiB1eDtcbiAgICBvdXQuYyA9IGMgLSBiICogdXggKyBhICogdXggKiB1eCArIHV5O1xuICAgIG91dC5wcmVkaWN0ID0gZm47XG4gICAgb3V0LnJTcXVhcmVkID0gZGV0ZXJtaW5hdGlvbihkYXRhLCB4LCB5LCBZLCBmbik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHF1YWRyYXRpYy5kb21haW4gPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gYXJyLCBxdWFkcmF0aWMpIDogZG9tYWluO1xuICB9O1xuXG4gIHF1YWRyYXRpYy54ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IGZuLCBxdWFkcmF0aWMpIDogeDtcbiAgfTtcblxuICBxdWFkcmF0aWMueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcXVhZHJhdGljKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIHF1YWRyYXRpYztcbn1cblxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vVG9tLUFsZXhhbmRlci9yZWdyZXNzaW9uLWpzL2Jsb2IvbWFzdGVyL3NyYy9yZWdyZXNzaW9uLmpzI0wyNDZcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub20tQWxleGFuZGVyL3JlZ3Jlc3Npb24tanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLy8gLi4ud2l0aCBpZGVhcyBmcm9tIHZlZ2Etc3RhdGlzdGljcyBieSBKZWZmcmV5IEhlZXJcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YyMWNiODc5MmI0ZTBjYmUyYjFhM2ZkNDRiMGY1ZGIzNzBkYmFhZGIvcGFja2FnZXMvdmVnYS1zdGF0aXN0aWNzL3NyYy9yZWdyZXNzaW9uL3BvbHkuanNcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EvYmxvYi9mMDU4YjA5OWRlY2FkOWRiNzgzMDE0MDVkZDBkMmU5ZDhiYTNkNTFhL0xJQ0VOU0VcblxuZnVuY3Rpb24gcG9seW5vbWlhbCAoKSB7XG4gIHZhciB4ID0gZnVuY3Rpb24geChkKSB7XG4gICAgcmV0dXJuIGRbMF07XG4gIH0sXG4gICAgICB5ID0gZnVuY3Rpb24geShkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH0sXG4gICAgICBvcmRlciA9IDMsXG4gICAgICBkb21haW47XG5cbiAgZnVuY3Rpb24gcG9seW5vbWlhbChkYXRhKSB7XG4gICAgLy8gVXNlIG1vcmUgZWZmaWNpZW50IG1ldGhvZHMgZm9yIGxvd2VyIG9yZGVyc1xuICAgIGlmIChvcmRlciA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBsaW5lYXIoKS54KHgpLnkoeSkuZG9tYWluKGRvbWFpbikoZGF0YSk7XG4gICAgICBvLmNvZWZmaWNpZW50cyA9IFtvLmIsIG8uYV07XG4gICAgICBkZWxldGUgby5hO1xuICAgICAgZGVsZXRlIG8uYjtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgdmFyIF9vID0gcXVhZCgpLngoeCkueSh5KS5kb21haW4oZG9tYWluKShkYXRhKTtcblxuICAgICAgX28uY29lZmZpY2llbnRzID0gW19vLmMsIF9vLmIsIF9vLmFdO1xuICAgICAgZGVsZXRlIF9vLmE7XG4gICAgICBkZWxldGUgX28uYjtcbiAgICAgIGRlbGV0ZSBfby5jO1xuICAgICAgcmV0dXJuIF9vO1xuICAgIH1cblxuICAgIHZhciBfcG9pbnRzID0gcG9pbnRzKGRhdGEsIHgsIHkpLFxuICAgICAgICBfcG9pbnRzMiA9IF9zbGljZWRUb0FycmF5KF9wb2ludHMsIDQpLFxuICAgICAgICB4diA9IF9wb2ludHMyWzBdLFxuICAgICAgICB5diA9IF9wb2ludHMyWzFdLFxuICAgICAgICB1eCA9IF9wb2ludHMyWzJdLFxuICAgICAgICB1eSA9IF9wb2ludHMyWzNdLFxuICAgICAgICBuID0geHYubGVuZ3RoLFxuICAgICAgICBsaHMgPSBbXSxcbiAgICAgICAgcmhzID0gW10sXG4gICAgICAgIGsgPSBvcmRlciArIDE7XG5cbiAgICB2YXIgWSA9IDAsXG4gICAgICAgIG4wID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgKytuMDtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuMDtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgaWYgKGR4IDwgeG1pbikgeG1pbiA9IGR4O1xuICAgICAgICBpZiAoZHggPiB4bWF4KSB4bWF4ID0gZHg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGksIGosIGwsIHYsIGM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgICBmb3IgKGwgPSAwLCB2ID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpKSAqIHl2W2xdO1xuICAgICAgfVxuXG4gICAgICBsaHMucHVzaCh2KTtcbiAgICAgIGMgPSBuZXcgRmxvYXQ2NEFycmF5KGspO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgIGZvciAobCA9IDAsIHYgPSAwOyBsIDwgbjsgKytsKSB7XG4gICAgICAgICAgdiArPSBNYXRoLnBvdyh4dltsXSwgaSArIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgY1tqXSA9IHY7XG4gICAgICB9XG5cbiAgICAgIHJocy5wdXNoKGMpO1xuICAgIH1cblxuICAgIHJocy5wdXNoKGxocyk7XG5cbiAgICB2YXIgY29lZiA9IGdhdXNzaWFuRWxpbWluYXRpb24ocmhzKSxcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICB4IC09IHV4O1xuICAgICAgdmFyIHkgPSB1eSArIGNvZWZbMF0gKyBjb2VmWzFdICogeCArIGNvZWZbMl0gKiB4ICogeDtcblxuICAgICAgZm9yIChpID0gMzsgaSA8IGs7ICsraSkge1xuICAgICAgICB5ICs9IGNvZWZbaV0gKiBNYXRoLnBvdyh4LCBpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHk7XG4gICAgfSxcbiAgICAgICAgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcblxuICAgIG91dC5jb2VmZmljaWVudHMgPSB1bmNlbnRlcihrLCBjb2VmLCAtdXgsIHV5KTtcbiAgICBvdXQucHJlZGljdCA9IGZuO1xuICAgIG91dC5yU3F1YXJlZCA9IGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgWSwgZm4pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBwb2x5bm9taWFsLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIHBvbHlub21pYWwpIDogZG9tYWluO1xuICB9O1xuXG4gIHBvbHlub21pYWwueCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBmbiwgcG9seW5vbWlhbCkgOiB4O1xuICB9O1xuXG4gIHBvbHlub21pYWwueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcG9seW5vbWlhbCkgOiB5O1xuICB9O1xuXG4gIHBvbHlub21pYWwub3JkZXIgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gbiwgcG9seW5vbWlhbCkgOiBvcmRlcjtcbiAgfTtcblxuICByZXR1cm4gcG9seW5vbWlhbDtcbn1cblxuZnVuY3Rpb24gdW5jZW50ZXIoaywgYSwgeCwgeSkge1xuICB2YXIgeiA9IEFycmF5KGspO1xuICB2YXIgaSwgaiwgdiwgYzsgLy8gaW5pdGlhbGl6ZSB0byB6ZXJvXG5cbiAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIHpbaV0gPSAwO1xuICB9IC8vIHBvbHlub21pYWwgZXhwYW5zaW9uXG5cblxuICBmb3IgKGkgPSBrIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2ID0gYVtpXTtcbiAgICBjID0gMTtcbiAgICB6W2ldICs9IHY7XG5cbiAgICBmb3IgKGogPSAxOyBqIDw9IGk7ICsraikge1xuICAgICAgYyAqPSAoaSArIDEgLSBqKSAvIGo7IC8vIGJpbm9taWFsIGNvZWZmaWNlbnRcblxuICAgICAgeltpIC0gal0gKz0gdiAqIE1hdGgucG93KHgsIGopICogYztcbiAgICB9XG4gIH0gLy8gYmlhcyB0ZXJtXG5cblxuICB6WzBdICs9IHk7XG4gIHJldHVybiB6O1xufSAvLyBHaXZlbiBhbiBhcnJheSBmb3IgYSB0d28tZGltZW5zaW9uYWwgbWF0cml4IGFuZCB0aGUgcG9seW5vbWlhbCBvcmRlcixcbi8vIHNvbHZlIEEgKiB4ID0gYiB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbi5cblxuXG5mdW5jdGlvbiBnYXVzc2lhbkVsaW1pbmF0aW9uKG1hdHJpeCkge1xuICB2YXIgbiA9IG1hdHJpeC5sZW5ndGggLSAxLFxuICAgICAgY29lZiA9IFtdO1xuICB2YXIgaSwgaiwgaywgciwgdDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgciA9IGk7IC8vIG1heCByb3dcblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobWF0cml4W2ldW2pdKSA+IE1hdGguYWJzKG1hdHJpeFtpXVtyXSkpIHtcbiAgICAgICAgciA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gaTsgayA8IG4gKyAxOyArK2spIHtcbiAgICAgIHQgPSBtYXRyaXhba11baV07XG4gICAgICBtYXRyaXhba11baV0gPSBtYXRyaXhba11bcl07XG4gICAgICBtYXRyaXhba11bcl0gPSB0O1xuICAgIH1cblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBmb3IgKGsgPSBuOyBrID49IGk7IGstLSkge1xuICAgICAgICBtYXRyaXhba11bal0gLT0gbWF0cml4W2tdW2ldICogbWF0cml4W2ldW2pdIC8gbWF0cml4W2ldW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaiA9IG4gLSAxOyBqID49IDA7IC0taikge1xuICAgIHQgPSAwO1xuXG4gICAgZm9yIChrID0gaiArIDE7IGsgPCBuOyArK2spIHtcbiAgICAgIHQgKz0gbWF0cml4W2tdW2pdICogY29lZltrXTtcbiAgICB9XG5cbiAgICBjb2VmW2pdID0gKG1hdHJpeFtuXVtqXSAtIHQpIC8gbWF0cml4W2pdW2pdO1xuICB9XG5cbiAgcmV0dXJuIGNvZWY7XG59XG5cbmZ1bmN0aW9uIHBvd2VyICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGRvbWFpbjtcblxuICBmdW5jdGlvbiBwb3dlcihkYXRhKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBYID0gMCxcbiAgICAgICAgWSA9IDAsXG4gICAgICAgIFhZID0gMCxcbiAgICAgICAgWDIgPSAwLFxuICAgICAgICBZUyA9IDAsXG4gICAgICAgIHhtaW4gPSBkb21haW4gPyArZG9tYWluWzBdIDogSW5maW5pdHksXG4gICAgICAgIHhtYXggPSBkb21haW4gPyArZG9tYWluWzFdIDogLUluZmluaXR5O1xuICAgIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgIHZhciBseCA9IE1hdGgubG9nKGR4KSxcbiAgICAgICAgICBseSA9IE1hdGgubG9nKGR5KTtcbiAgICAgICsrbjtcbiAgICAgIFggKz0gKGx4IC0gWCkgLyBuO1xuICAgICAgWSArPSAobHkgLSBZKSAvIG47XG4gICAgICBYWSArPSAobHggKiBseSAtIFhZKSAvIG47XG4gICAgICBYMiArPSAobHggKiBseCAtIFgyKSAvIG47XG4gICAgICBZUyArPSAoZHkgLSBZUykgLyBuO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfb2xzID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgICAgIF9vbHMyID0gX3NsaWNlZFRvQXJyYXkoX29scywgMiksXG4gICAgICAgIGEgPSBfb2xzMlswXSxcbiAgICAgICAgYiA9IF9vbHMyWzFdO1xuXG4gICAgYSA9IE1hdGguZXhwKGEpO1xuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oeCkge1xuICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdyh4LCBiKTtcbiAgICB9LFxuICAgICAgICBvdXQgPSBpbnRlcnBvc2UoeG1pbiwgeG1heCwgZm4pO1xuXG4gICAgb3V0LmEgPSBhO1xuICAgIG91dC5iID0gYjtcbiAgICBvdXQucHJlZGljdCA9IGZuO1xuICAgIG91dC5yU3F1YXJlZCA9IGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgWVMsIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgcG93ZXIuZG9tYWluID0gZnVuY3Rpb24gKGFycikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IGFyciwgcG93ZXIpIDogZG9tYWluO1xuICB9O1xuXG4gIHBvd2VyLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIHBvd2VyKSA6IHg7XG4gIH07XG5cbiAgcG93ZXIueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcG93ZXIpIDogeTtcbiAgfTtcblxuICByZXR1cm4gcG93ZXI7XG59XG5cbmV4cG9ydCB7IGV4cG9uZW50aWFsIGFzIHJlZ3Jlc3Npb25FeHAsIGxpbmVhciBhcyByZWdyZXNzaW9uTGluZWFyLCBsb2VzcyBhcyByZWdyZXNzaW9uTG9lc3MsIGxvZ2FyaXRobWljIGFzIHJlZ3Jlc3Npb25Mb2csIHBvbHlub21pYWwgYXMgcmVncmVzc2lvblBvbHksIHBvd2VyIGFzIHJlZ3Jlc3Npb25Qb3csIHF1YWQgYXMgcmVncmVzc2lvblF1YWQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-regression/dist/d3-regression.esm.js\n");

/***/ })

};
;